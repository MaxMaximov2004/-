Р Лаффоре ст476
Если нам необходимо создать указатель на два схожиих, но различающися класса с различными методами (которые в контексте этих классов выполняют схожие если не одинаковые дейсствия),
то есть причина создать родительский класс, содержащий виртуальный метод (далее виртуальная функция), и использовать этот класс для создания указателя на эти 2 класса 

А если необходимо обеспечить безопасность родительскому классу, от других программистов (т.к. там могут быть методы для использования их другими классами и в теории они могут сломать всё, если их бездумно будеть использовать программист)
то родительский класс можно сделать абстрактным включив в него хотя-бы 1 виртуалную функцию.

P.S. Если в родительском классе присутствует деструктор и виртуальные функции, то он также должен быть виртуальным, иначе будут удалятся толко данные относящиеся к родительскому классу, при вызове деструктора производного класса.
(Р Лафорре ст488)


#include <iostream>
#include <string>

class class_a {
public:
	virtual std::string print() = 0;/*виртуальная функция (чистая, без =0 это не чистая функция	(не в том смысле, что грязная, связанная с колдовством или уродливая)) */
};

class class_b: public class_a {
public:
	std::string print() { /*метод print класса Б говорит что это класс Б*/
		return("It`s class B\n");
	}
};
class class_с :public class_a {/*метод print класса С говорит что это класс С*/
public:
	std::string print() {
		return("It`s class C\n");
	}
};

int main()
{
	class_b test_b;
	class_с test_c;

	class_a* P = &test_b;
	std::cout << P->print();

	P = &test_c;
	std::cout << P->print();

	//class_a test_a; //так делать нельзя
}


